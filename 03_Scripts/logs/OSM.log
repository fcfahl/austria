21:48:33 WARNING  is when this event was logged.
21:48:33 INFO     
        DROP FUNCTION IF EXISTS jrc_01_get_farm_ids (id_target_ int, distance int);
        CREATE OR REPLACE FUNCTION jrc_01_get_farm_ids (id_target_ int, distance int)
        RETURNS table (id_building1 int) AS
        $$
            
    	SELECT DISTINCT a.id_building
    	FROM (Select * from topo_targets where id_building > 0) as a
    	JOIN (Select * from topo_targets where id_target = $1) as b
    	ON ST_DWithin (a.geom, b.geom, $2)

    
        $$ LANGUAGE SQL;
    
21:48:33 INFO     
        DROP FUNCTION IF EXISTS jrc_02_get_road_node (id_target_ int, id_farm_ int);
        CREATE OR REPLACE FUNCTION jrc_02_get_road_node (id_target_ int, id_farm_ int)
        RETURNS table (id_target2 int, id_building2 int, node_target2 bigint, node_farm2 bigint, dist2 double precision) AS
        $$
            
    	WITH
    	farm as (
    		SELECT 	a.id as id_node, b.id_building, ST_Distance(a.the_geom, b.geom) as dist
    		FROM 	topo_roads_noded_vertices_pgr AS a,
    			(Select * from topo_targets where id_building = $2) AS b
    		WHERE 	ST_DWithin (a.the_geom, b.geom, 500) 
		ORDER BY dist ASC limit 1
    	),
    	target as (
    		SELECT a.id as id_node, b.id_target, ST_Distance(a.the_geom, b.geom) as dist
    		FROM 	topo_roads_noded_vertices_pgr AS a,
    			(Select * from topo_targets where id_target = $1) AS b
    		WHERE 	ST_DWithin (a.the_geom, b.geom, 500) 
		ORDER BY dist ASC limit 1
    	)
    	SELECT target.id_target, farm.id_building, target.id_node, farm.id_node, target.dist
    	FROM farm, target

    
        $$ LANGUAGE SQL;
    
21:48:33 INFO     
        DROP FUNCTION IF EXISTS jrc_03_get_node_arrays (id_target_ int, distance int);
        CREATE OR REPLACE FUNCTION jrc_03_get_node_arrays (id_target_ int, distance int)
        RETURNS table (id_target3 int, id_building3 int, node_target3 int, node_building3 int) AS
        $$
    	DECLARE
    		n_buildings int[]; i integer;
    	BEGIN
            
    	n_buildings := ((SELECT array_agg(id_building1) FROM jrc_01_get_farm_ids (
    		(SELECT id_target FROM topo_targets WHERE id_target = $1), $2))::int[]);

    	FOR i IN 1 .. array_upper(n_buildings, 1)
    	LOOP
            id_target3 := $1;
    		id_building3 := n_buildings[i];

			node_target3 := (SELECT node_target2 FROM jrc_02_get_road_node (
					(SELECT id_target FROM topo_targets WHERE id_target =  $1),
					(SELECT id_building FROM topo_targets WHERE id_building =  n_buildings[i]))) ;


    		node_building3 := (select node_farm2 from jrc_02_get_road_node (
    	  			(SELECT id_target FROM topo_targets WHERE id_target =  $1),
    				(SELECT id_building FROM topo_targets WHERE id_building =  n_buildings[i]))) ;

    	  	-- RAISE NOTICE 'The id is : % and the node is : % s', n_buildings[i] , node_building2;

    		RETURN NEXT;
    	END LOOP;
    
    	END;
        $$ LANGUAGE PLPGSQL;
    
21:48:33 INFO     
        DROP FUNCTION IF EXISTS jrc_04_routes (id_target_ int, id_building_ int[], node_target_ int,  node_farm_ int[]);
        CREATE OR REPLACE FUNCTION jrc_04_routes (id_target_ int, id_building_ int[], node_target_ int,  node_farm_ int[])
        RETURNS table (id_target4 int, id_building4 int, length double precision, geom geometry) AS
        $$
    	DECLARE
    		n_buildings int[]; i integer;
    	BEGIN
            
        RETURN QUERY
        WITH
            target_id_1 AS (SELECT id_target_ AS id_target_1),
            target_node_1 AS (SELECT node_target_ AS node_target_1),
            farm_id_array_1 AS (SELECT id_building_ AS id_farm_array_1),
            farm_node_array_1 AS (SELECT node_farm_ AS node_farm_array_1),

            dijkstra as (
            	SELECT
            	    dijkstra.*, topo_roads_noded.geom
            	FROM	pgr_dijkstra(
            		'SELECT id, source::integer, target::integer, distance::double precision AS cost FROM topo_roads_noded',
            		$3, $4,false) AS dijkstra
            	LEFT JOIN
            	    topo_roads_noded
            	ON
            	    (edge = id)
            	ORDER BY
            	    seq
            ),
            join_ids AS (
            	SELECT b.farm_, a.*
            	FROM dijkstra a
            	LEFT JOIN (SELECT * FROM route_node_ids) AS b
            	ON (a.end_vid = b.node_farm_)
            ),
            routes AS (
            	SELECT c.farm_, ST_Multi(ST_LineMerge(ST_Collect(c.geom))) AS geom
            	FROM join_ids AS c
            	GROUP BY c.farm_
            ),
            merge_results AS (
            	SELECT d.farm_, d.geom
            	FROM routes AS d
            	LEFT JOIN topo_targets AS e
            	ON (d.farm_ = e.id_building)
            	ORDER BY d.farm_
            )
            SELECT id_target_ AS  id_target4, f.farm_, ST_Length(f.geom), f.geom FROM merge_results AS f  ;

            --RAISE NOTICE 'target id / node  = % | % ', id_target_, node_target_;
            --RAISE NOTICE 'farm id / node = % | % ', id_building_, node_farm_;
            --RAISE NOTICE '';

    
    	END;
        $$ LANGUAGE PLPGSQL;
    
21:48:33 INFO     DROP TABLE IF EXISTS route_distance_4km;
CREATE TABLE route_distance_4km (id_target int, id_building int, length double precision );
21:48:33 INFO     SELECT AddGeometryColumn ('public', 'route_distance_4km','geom', 3035, 'multilinestring', 2);
21:48:33 INFO     DROP TABLE IF EXISTS route_targets;
CREATE TABLE route_targets AS
SELECT id_target, geom
FROM topo_targets
WHERE id_target <= 2;
21:48:33 INFO     DROP TABLE IF EXISTS route_node_ids;
CREATE TABLE route_node_ids (target_ int, farm_ int, node_target_ int, node_farm_ int );
21:48:33 INFO     
    DO
    $$
    DECLARE
        
    	i integer;
    	distance int := 4000;
    	n_targets int[];
    	id_target_ int;
    	node_target_ int;
    	id_building_ int[];
    	node_building_ int[];
    	n_farms int;
    	results RECORD;
    	geom_ geometry;
    
    BEGIN
    	-- Get number of target points
    	n_targets := (SELECT array_agg(id_target) FROM route_targets);

    	-- Perform the Loop
    	FOR i IN 1 .. array_upper(n_targets, 1)
    	LOOP

    		id_target_ := n_targets[i];

    		-- Get the id nodes (from roads) of the target and farm locations within a given distance
    		INSERT INTO "route_node_ids" (target_, farm_, node_target_, node_farm_)
    			SELECT id_target3 AS target_, id_building3 AS farm_,
    				node_target3 AS node_target_, node_building3 AS node_farm_
    			FROM jrc_03_get_node_arrays (id_target_, distance);

    		-- Assign the ids to variables
    	 	node_target_ := (SELECT a.node_target_ FROM route_node_ids AS a WHERE target_ = id_target_ LIMIT 1);
    		id_building_ := (SELECT array_agg(farm_) FROM route_node_ids WHERE target_ = id_target_);
    		node_building_ := (SELECT array_agg(node_farm_) FROM route_node_ids);

    		n_farms := (SELECT COUNT (*) FROM route_node_ids);

    		RAISE NOTICE 'target id / node  = % | % ', id_target_, node_target_;
    		RAISE NOTICE 'number of farms = % ', n_farms;
    		RAISE NOTICE 'farm id / node = % | % ', id_building_, node_building_;
    		RAISE NOTICE '';

    		-- Do the routing between the target (point) and the farms (array)

    		INSERT INTO "route_distance_4km" (id_target, id_building, length, geom)
    		SELECT id_target4, id_building4, length, geom FROM jrc_04_routes (id_target_, id_building_, node_target_, node_building_);

    	END LOOP;
    END
    $$;


    
